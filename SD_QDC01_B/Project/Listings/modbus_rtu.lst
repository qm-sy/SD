C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt-1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt-2]<<8);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX4_buf[0] == MY_ADDR )
  34   3                  {
  35   4                      switch ( rs485.RX4_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          
  61          /**
  62           * @brief       读输入寄存器  03
  63           *
  64           * @param   void
  65           *
  66           * @return  void 
  67          **/
  68          void Modbus_Fun3( void )
  69          {
  70   1          uint16_t i;
  71   1      
  72   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
  73   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
  74   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
  75   1      
  76   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
  77   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
  78   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
  79   1      
  80   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
  81   1          {
  82   2              /*    每次循环前初始化byte_info                       */
  83   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  84   2              switch (i)
  85   2              {   
  86   3                  /*  40001 风速查询                     */
  87   3                  case 0x00:
  88   3                      modbus.byte_info_L = PWMB_CCR7 / 184;
  89   3                      modbus.byte_info_H = 0x00;
  90   3      
  91   3                      break;
  92   3      
  93   3                  /*  40002 LED开关状态查询                     */    
  94   3                  case 0x01:
  95   3                      modbus.byte_info_L = ~LED;
  96   3                      modbus.byte_info_H = 0X00;
  97   3                      break;
  98   3      
  99   3                  /*  40003 3路220V开关使能查询                         */
 100   3                  case 0x02:    
 101   3                      modbus.byte_info_L = (ac_dc.ac220_out1_enable) | (ac_dc.ac220_out2_enable << 1) | (ac_dc.a
             -c220_out3_enable << 2);
 102   3                      modbus.byte_info_H = (ac_dc.time_delay - 58000)/75;
 103   3      
 104   3                      break;
 105   3      
 106   3                  /*  40004 同步状态查询              */
 107   3                  case 0x03:    
 108   3                      modbus.byte_info_L = ac_dc.sync_flag;
 109   3                      modbus.byte_info_H = 0X00;  
 110   3      
 111   3                      break;
 112   3      
 113   3                  /*  40005 工作模式查询                     */
 114   3                  case 0x04:   
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 3   

 115   3                      modbus.byte_info_L = ac_dc.mode_info;
 116   3                      modbus.byte_info_H = 0X00;                    
 117   3      
 118   3                      break;
 119   3      
 120   3                  /*  40006 报警温度查询                     */
 121   3                  case 5:   
 122   3                      modbus.byte_info_L = temp.temp_alarm_value;
 123   3                      modbus.byte_info_H = 0X00;                    
 124   3      
 125   3                      break;
 126   3                  default:
 127   3                      break;
 128   3              }
 129   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 130   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 131   2          }
 132   1          slave_to_master(0x03,3 + modbus.byte_cnt);
 133   1      }
 134          
 135          /**
 136           * @brief       读输出寄存器  04
 137           *
 138           * @param   void
 139           *
 140           * @return  void 
 141          **/
 142          void Modbus_Fun4( void )
 143          {
 144   1          uint16_t i;
 145   1      
 146   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 147   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 148   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 149   1      
 150   1          rs485.TX4_buf[0]  = MY_ADDR;                //Addr
 151   1          rs485.TX4_buf[1]  = 0x04;                   //Fun
 152   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 153   1      
 154   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 155   1          {
 156   2              /*    每次循环前初始化byte_info                       */
 157   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 158   2              switch (i)
 159   2              {
 160   3                  /*  30001  NTC1、NTC2温度查询                           */
 161   3                  case 0x00:
 162   3                      modbus.byte_info_L = get_temp(NTC);
 163   3                      modbus.byte_info_H = 0x00;   
 164   3      
 165   3                      break;
 166   3      
 167   3                  /*  30002  NTC3、NTC4温度查询                */
 168   3                  case 0x01:
 169   3                      modbus.byte_info_H = 0x00;    
 170   3                      modbus.byte_info_L = 0x00;
 171   3      
 172   3                      break;
 173   3      
 174   3                  /*  30003 环境温湿度查询                   */
 175   3                  case 0x02:
 176   3                      modbus.byte_info_H = temp.dht11_humidity;           
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 4   

 177   3                      modbus.byte_info_L = temp.dht11_temp;          
 178   3      
 179   3                      break;
 180   3      
 181   3                  /*  30004 Signal_IN状态查询                   */
 182   3                  case 0x03:
 183   3                      modbus.byte_info_H = 0x00;           
 184   3                      modbus.byte_info_L = ac_dc.signal_in_flag;          
 185   3      
 186   3                      break;
 187   3                      
 188   3                  /*  30005 运行时间（min）                   */
 189   3                  case 0x04:
 190   3                      modbus.byte_info_H = 0x00;           
 191   3                      modbus.byte_info_L = gonglv.gonglv_min;          
 192   3      
 193   3                      break;
 194   3      
 195   3                  /*  30006 运行时间（h）                   */
 196   3                  case 0x05:
 197   3                      modbus.byte_info_H = gonglv.gonglv_h >> 8;           
 198   3                      modbus.byte_info_L = gonglv.gonglv_h;          
 199   3      
 200   3                      break;
 201   3      
 202   3                  default:
 203   3                      break;
 204   3              }
 205   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 206   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 207   2          }
 208   1          slave_to_master(0x04,3 + modbus.byte_cnt);
 209   1      }
 210          
 211          /**
 212           * @brief       写单个输出寄存器  06
 213           *
 214           * @param   void
 215           *
 216           * @return  void 
 217          **/
 218          void Modbus_Fun6( void )
 219          {
 220   1          switch (rs485.RX4_buf[3])
 221   1          {
 222   2              /*  40001  风速设置                 */
 223   2              case 0x00:                  
 224   2                  fan_ctrl(rs485.RX4_buf[5]);
 225   2      
 226   2                  eeprom.pwm_info = rs485.RX4_buf[5];
 227   2      
 228   2                  break;
 229   2      
 230   2              /*  40002  LED 开关状态设置                          */
 231   2              case 0x01:                                         
 232   2      
 233   2                  led_ctrl(rs485.RX4_buf[5]);
 234   2      
 235   2                  eeprom.led_info = rs485.RX4_buf[5];
 236   2      
 237   2                  break;
 238   2      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 5   

 239   2              /*  40003 三路220V输出使能设置                          */
 240   2              case 0x02:                                         
 241   2                  ac_dc.ac220_out1_enable = (rs485.RX4_buf[5]    & 0x01);
 242   2                  ac_dc.ac220_out2_enable = (rs485.RX4_buf[5]>>1 & 0x01);
 243   2                  ac_dc.ac220_out3_enable = (rs485.RX4_buf[5]>>2 & 0x01);
 244   2                  ac_220v_crl(rs485.RX4_buf[4]);
 245   2                  
 246   2                  eeprom.ac220_switch = rs485.RX4_buf[5];
 247   2                  eeprom.ac220_level  = rs485.RX4_buf[4];
 248   2                  break;  
 249   2                  
 250   2              /*  40004  同步状态设置                   */
 251   2              case 0x03:                                         
 252   2                  ac_dc.sync_flag = rs485.RX4_buf[5];
 253   2                  sync_ctrl();
 254   2      
 255   2                  eeprom.sync_info = rs485.RX4_buf[5];
 256   2      
 257   2                  break;
 258   2      
 259   2              /*  40005  工作模式设置                   */
 260   2              case 0x04:                                         
 261   2                  ac_dc.mode_info = rs485.RX4_buf[5];
 262   2                  mode_ctrl(ac_dc.mode_info);
 263   2      
 264   2                  eeprom.mode_info = rs485.RX4_buf[5];
 265   2      
 266   2                  break;
 267   2      
 268   2              /*  40006  报警温度设置                   */
 269   2              case 0x05:                                         
 270   2                  temp.temp_alarm_value = rs485.RX4_buf[5];
 271   2      
 272   2                  eeprom.temp_alarm_value = rs485.RX4_buf[5];
 273   2                  
 274   2                  break;
 275   2      
 276   2              default:
 277   2                  break;   
 278   2          }
 279   1      
 280   1          slave_to_master(0x06,8);
 281   1      
 282   1          eeprom_data_record();
 283   1      }
 284          
 285          /**
 286           * @brief       写多个输出寄存器  16
 287           *
 288           * @param   void
 289           *
 290           * @return  void 
 291          **/
 292          void Modbus_Fun16( void )
 293          {
 294   1          uint16_t i;
 295   1      
 296   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 297   1          modbus.byte_cnt   = rs485.RX4_buf[6];
 298   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 299   1      
 300   1          
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 6   

 301   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 302   1          {
 303   2              modbus.byte_info_H = rs485.RX4_buf[modbus.rcv_value_addr];
 304   2              modbus.byte_info_L = rs485.RX4_buf[modbus.rcv_value_addr + 1];
 305   2              switch (i)
 306   2              {
 307   3                  /*  40001  风速设置                 */
 308   3                  case 0x00:
 309   3                      fan_ctrl(modbus.byte_info_L);
 310   3      
 311   3                      eeprom.pwm_info = modbus.byte_info_L;
 312   3      
 313   3                      break;
 314   3                  
 315   3                  /*  40002  LED 开关状态设置                          */
 316   3                  case 0x01:
 317   3                      led_ctrl(modbus.byte_info_L);
 318   3      
 319   3                      eeprom.led_info = modbus.byte_info_L;
 320   3      
 321   3                      break;
 322   3      
 323   3                  /*  40003 三路220V输出使能设置                          */
 324   3                  case 0x02:
 325   3                      ac_dc.ac220_out1_enable = (modbus.byte_info_L    & 0x01);
 326   3                      ac_dc.ac220_out2_enable = (modbus.byte_info_L>>1 & 0x01);
 327   3                      ac_dc.ac220_out3_enable = (modbus.byte_info_L>>2 & 0x01);
 328   3                      ac_220v_crl(modbus.byte_info_H);
 329   3      
 330   3                      eeprom.ac220_switch = modbus.byte_info_L;
 331   3                      eeprom.ac220_level  = modbus.byte_info_H;
 332   3      
 333   3                      break;
 334   3      
 335   3                  
 336   3                  /*  40004  同步状态设置                   */
 337   3                  case 0x03:
 338   3                      ac_dc.sync_flag = modbus.byte_info_L;
 339   3                      sync_ctrl();
 340   3      
 341   3                      eeprom.sync_info = modbus.byte_info_L;
 342   3      
 343   3                      break;
 344   3      
 345   3                  /*  40005  工作模式设置                   */
 346   3                  case 0x04:                                         
 347   3                      ac_dc.mode_info = modbus.byte_info_L;
 348   3                      if( modbus.byte_info_H == 1)
 349   3                      {
 350   4                          mode_ctrl(ac_dc.mode_info);
 351   4                      }
 352   3      
 353   3                      eeprom.mode_info = modbus.byte_info_L;
 354   3      
 355   3                      break;
 356   3      
 357   3                  /*  40006  报警温度设置                   */
 358   3                  case 0x05:                                         
 359   3                      temp.temp_alarm_value = modbus.byte_info_L;
 360   3      
 361   3                      eeprom.temp_alarm_value = modbus.byte_info_L;
 362   3                      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 7   

 363   3                      break;
 364   3                      
 365   3                  default:
 366   3                      break;
 367   3              }
 368   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 369   2          }
 370   1      
 371   1          slave_to_master(0x10,8);
 372   1      
 373   1          eeprom_data_record();                      //记录更改后的值
 374   1      }
 375          
 376          
 377          /**
 378           * @brief       从机回复主机
 379           *  
 380           * @param   code_num:功能码       
 381           * @param   length:数据长度        
 382           * 
 383            @return  crc16:crc校验的值 2byte
 384           */
 385          void slave_to_master(uint8_t code_num,uint8_t length)
 386          {
 387   1          uint16_t crc;
 388   1      
 389   1          switch (code_num)
 390   1          {
 391   2              case 0x03:
 392   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 393   2      
 394   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 395   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 396   2      
 397   2                  rs485.TX4_send_bytelength = length + 2;
 398   2                  
 399   2                  break;
 400   2              case 0x04:
 401   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 402   2      
 403   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 404   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 405   2      
 406   2                  rs485.TX4_send_bytelength = length + 2;
 407   2                  
 408   2                  break;    
 409   2      
 410   2              case 0x06:
 411   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 412   2      
 413   2                  rs485.TX4_send_bytelength = length;
 414   2                  
 415   2                  break;   
 416   2      
 417   2              case 0x10:
 418   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 419   2              
 420   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 421   2      
 422   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 423   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 424   2              
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 8   

 425   2                  rs485.TX4_send_bytelength = length;
 426   2                  
 427   2                  break;         
 428   2      
 429   2              default:
 430   2                  break;
 431   2          }
 432   1      
 433   1          DR_485 = 1;                                 //485可以发送
 434   1          delay_ms(2);
 435   1          S4CON |= S4TI;                              //开始发送
 436   1          delay_ms(1);
 437   1      }
 438          
 439          
 440          /**
 441           * @brief       crc校验函数
 442           * 
 443           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 444           * @param   length:数据长度           
 445           * 
 446            @return  crc16:crc校验的值 2byte
 447           */
 448          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 449          {
 450   1              uint8_t i;
 451   1              uint16_t        crc16;
 452   1      
 453   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 454   1              crc16 = 0xffff; 
 455   1      
 456   1              do
 457   1              {
 458   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 459   2                      crc16 ^= (uint16_t)*buf;                //
 460   2                      for(i=0; i<8; i++)              
 461   2                      {
 462   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 463   3                              if(crc16 & 1)
 464   3                  {
 465   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 466   4                  }
 467   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 468   3                  else
 469   3                  {
 470   4                      crc16 >>= 1;
 471   4                  }           
 472   3                      }
 473   2                      buf++;
 474   2              }while(--length != 0);
 475   1      
 476   1              return  (crc16);
 477   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1577    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      12
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        06/03/2025 16:23:39 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
